# InversePI-16
#
# Copyright 2022, Chris Larsen
# You may use this code, without warranty expressed or implied, as you wish
# with the provision that any work derived from this code retains my
# copyright notice.
#
# Python script which uses Newton's Method to compute the reciprocal of a
# binary16 value.
#
# This script is not production quality code. It is only Proof Of Concept
# (POC) code. It expects to receive only IEEE 754 binary16 Normal numbers
# as input, and to generate only IEEE 754 Normal numbers as output.
#
# NO ATTEMPT IS MADE TO HANDLE:
# o NaNs,
# o Infinities,
# o Zeroes, or
# o Subnormal numbers.

import argparse
import sys

table = [ 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7e, 0x7e, 0x7e,
          0x7e, 0x7d, 0x7d, 0x7d, 0x7d, 0x7c, 0x7c, 0x7c,
          0x7c, 0x7b, 0x7b, 0x7b, 0x7b, 0x7a, 0x7a, 0x7a,
          0x7a, 0x79, 0x79, 0x79, 0x79, 0x78, 0x78, 0x78,
          0x78, 0x78, 0x77, 0x77, 0x77, 0x77, 0x76, 0x76,
          0x76, 0x76, 0x75, 0x75, 0x75, 0x75, 0x74, 0x74,
          0x74, 0x74, 0x74, 0x73, 0x73, 0x73, 0x73, 0x72,
          0x72, 0x72, 0x72, 0x72, 0x71, 0x71, 0x71, 0x71,
          0x70, 0x70, 0x70, 0x70, 0x70, 0x6f, 0x6f, 0x6f,
          0x6f, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6d, 0x6d,
          0x6d, 0x6d, 0x6d, 0x6c, 0x6c, 0x6c, 0x6c, 0x6b,
          0x6b, 0x6b, 0x6b, 0x6b, 0x6a, 0x6a, 0x6a, 0x6a,
          0x6a, 0x69, 0x69, 0x69, 0x69, 0x69, 0x68, 0x68,
          0x68, 0x68, 0x67, 0x67, 0x67, 0x67, 0x67, 0x66,
          0x66, 0x66, 0x66, 0x66, 0x65, 0x65, 0x65, 0x65,
          0x65, 0x64, 0x64, 0x64, 0x64, 0x64, 0x63, 0x63,
          0x63, 0x63, 0x63, 0x62, 0x62, 0x62, 0x62, 0x62,
          0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x60, 0x60,
          0x60, 0x60, 0x60, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
          0x5e, 0x5e, 0x5e, 0x5e, 0x5e, 0x5d, 0x5d, 0x5d,
          0x5d, 0x5d, 0x5d, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
          0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5a, 0x5a,
          0x5a, 0x5a, 0x5a, 0x59, 0x59, 0x59, 0x59, 0x59,
          0x59, 0x58, 0x58, 0x58, 0x58, 0x58, 0x57, 0x57,
          0x57, 0x57, 0x57, 0x57, 0x56, 0x56, 0x56, 0x56,
          0x56, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x54,
          0x54, 0x54, 0x54, 0x54, 0x54, 0x53, 0x53, 0x53,
          0x53, 0x53, 0x53, 0x52, 0x52, 0x52, 0x52, 0x52,
          0x52, 0x51, 0x51, 0x51, 0x51, 0x51, 0x51, 0x50,
          0x50, 0x50, 0x50, 0x50, 0x50, 0x4f, 0x4f, 0x4f,
          0x4f, 0x4f, 0x4f, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e,
          0x4e, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4c,
          0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4b, 0x4b,
          0x4b, 0x4b, 0x4b, 0x4b, 0x4a, 0x4a, 0x4a, 0x4a,
          0x4a, 0x4a, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,
          0x49, 0x48, 0x48, 0x48, 0x48, 0x48, 0x48, 0x47,
          0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x46, 0x46,
          0x46, 0x46, 0x46, 0x46, 0x45, 0x45, 0x45, 0x45,
          0x45, 0x45, 0x45, 0x44, 0x44, 0x44, 0x44, 0x44,
          0x44, 0x44, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43,
          0x43, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
          0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x40,
          0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3f, 0x3f,
          0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3e, 0x3e, 0x3e,
          0x3e, 0x3e, 0x3e, 0x3e, 0x3d, 0x3d, 0x3d, 0x3d,
          0x3d, 0x3d, 0x3d, 0x3d, 0x3c, 0x3c, 0x3c, 0x3c,
          0x3c, 0x3c, 0x3c, 0x3b, 0x3b, 0x3b, 0x3b, 0x3b,
          0x3b, 0x3b, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a,
          0x3a, 0x3a, 0x39, 0x39, 0x39, 0x39, 0x39, 0x39,
          0x39, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
          0x38, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37, 0x37,
          0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
          0x36, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35,
          0x35, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34,
          0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
          0x33, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
          0x32, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
          0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
          0x30, 0x30, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f,
          0x2f, 0x2f, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e, 0x2e,
          0x2e, 0x2e, 0x2e, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d,
          0x2d, 0x2d, 0x2d, 0x2d, 0x2c, 0x2c, 0x2c, 0x2c,
          0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2b, 0x2b, 0x2b,
          0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2a, 0x2a,
          0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x29,
          0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29, 0x29,
          0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
          0x28, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27, 0x27,
          0x27, 0x27, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26,
          0x26, 0x26, 0x26, 0x26, 0x25, 0x25, 0x25, 0x25,
          0x25, 0x25, 0x25, 0x25, 0x25, 0x24, 0x24, 0x24,
          0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x23,
          0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23,
          0x23, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
          0x22, 0x22, 0x22, 0x21, 0x21, 0x21, 0x21, 0x21,
          0x21, 0x21, 0x21, 0x21, 0x21, 0x20, 0x20, 0x20,
          0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1f,
          0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
          0x1f, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e, 0x1e,
          0x1e, 0x1e, 0x1e, 0x1e, 0x1d, 0x1d, 0x1d, 0x1d,
          0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1c, 0x1c,
          0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c, 0x1c,
          0x1c, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b,
          0x1b, 0x1b, 0x1b, 0x1b, 0x1a, 0x1a, 0x1a, 0x1a,
          0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x1a, 0x19,
          0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
          0x19, 0x19, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
          0x18, 0x18, 0x18, 0x18, 0x18, 0x17, 0x17, 0x17,
          0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
          0x17, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
          0x16, 0x16, 0x16, 0x16, 0x15, 0x15, 0x15, 0x15,
          0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
          0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
          0x14, 0x14, 0x14, 0x14, 0x13, 0x13, 0x13, 0x13,
          0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13, 0x13,
          0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
          0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x11, 0x11,
          0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
          0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
          0x10, 0x10, 0x10, 0x10, 0x10, 0x0f, 0x0f, 0x0f,
          0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
          0x0f, 0x0f, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e,
          0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0d,
          0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0d,
          0x0d, 0x0d, 0x0d, 0x0d, 0x0c, 0x0c, 0x0c, 0x0c,
          0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
          0x0c, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
          0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a, 0x0a,
          0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
          0x0a, 0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x09, 0x09,
          0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
          0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
          0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
          0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06,
          0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
          0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05,
          0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
          0x05, 0x05, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04,
          0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
          0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
          0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
          0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
          0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
          0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ]

# Generate initial guess, x0, for Newton's Method
#
# Input:
#   - x: The 7 MSBs of the significand field for an IEEE 754
#        binary 16/32/64/128 value
#
# Returns:
#   - 8 significant bits of the initial value for x0
#
# While the function returns 8 significant bits it does so
# in a 9-bit field to be able to cover the entire range of
# possible values.
def X0(x):
  tmp = table[x]
  if x:
    return tmp | (1 << 7)
  else:
    return tmp | (1 << 8)

# Return arbitrary bit from an integer
#
# Inputs:
#   - x: integer from which to extract bit
#   - n: number of the bit to be returned counting from the least
#        significant bit. The least significant bit is numbered 0.
#
# Returns:
#   - The nth bit of the integer. Since the function returns a single bit
#     the only possible return values are 0 and 1.
def bit(x, n):
  return (x >> n) & 1;

# Insert binary point into a string representing a binary value
#
# Inputs:
#   - s: string containing binary value. The string has the prefix
#        "0b" followed by one or more digits of either 0 or 1.
#   - n: count of digits to the right of the binary point.
#
# If there aren't enough digits to have at least one binary digit
# to the left of position `n' then the function will left pad the
# string with zeroes.
def add_point(s, n):
  i = n+3 - len(s)
  if i > 0:
    t = s[:2] + (i * "0") + s[2:]
  else:
    t = s
  return t[0:-n] + "_" + t[-n:]

# Parse input arguments:
#
# Options:
#   -h, --help: emit a help string documenting command usage
#   --roundingAttribute: Specify how the final result is to be rounded
#                        Supported rounding modes:
#                        o roundTiesToEven, (default rounding mode)
#                        o roundTowardPositive,
#                        o roundTowardNegative, and
#                        o roundTowardZero.
#
# Input:
#   value: Integer which is to be interpreted as a binary16 value.
#          The value may be entered as binary, octal, decimal, or hexadecimal
#          integer. `value' is optional. If omitted the script will use the
#          hexadecimal value 0x4248 which is the binary16 approximation for π.
parser = argparse.ArgumentParser()
parser.add_argument("value", help="Compute reciprocal of this binary16 value; default = π", type=str, nargs="?", default="0x4248")
parser.add_argument("--roundingAttribute", help="Rounding mode for result", choices=["roundTiesToEven", "roundTowardPositive", "roundTowardNegative", "roundTowardZero"], default="roundTiesToEven", required=False)
args = parser.parse_args()

# Set the rounding mode flags:
roundTiesToEven = True if args.roundingAttribute == "roundTiesToEven" else False
roundTowardPositive = True if args.roundingAttribute == "roundTowardPositive" else False
roundTowardNegative = True if args.roundingAttribute == "roundTowardNegative" else False
roundTowardZero = True if args.roundingAttribute == "roundTowardZero" else False

#print("roundTiesToEven = " + str(roundTiesToEven))
#print("roundTowardPositive = " + str(roundTowardPositive))
#print("roundTowardNegative = " + str(roundTowardNegative))
#print("roundTowardZero = " + str(roundTowardZero))

# Read the string representing `value' and convert to an integer:
value = eval(args.value)
#print("value = " + str(value) + " (" + hex(value) + ")")

# Extract the sign, exponent, and significand fields.
# Add the implied leading one bit to the significand.
sign = (value & 0x8000) != 0
# Extract biased exponent value
exp = (value >> 10) & 0x1f
# So far, can only process Normal numbers:
if (exp == 0) or (exp == 31):
  sys.exit("This script can't process NaNs, Infinities, Zeroes, or Subnormal numbers.")

# Subtract BIAS value to get actual signed exponent
exp -= 15
# Compute starting exponent value for the reciprocal
rexp = -exp
# Extract significand and prepend the implicit leading 1 digit
sig = (value & 0x3ff) | (1 << 10)
# Show the user the values of the sign, unbiased exponent, and significand
print("sign, exponent, significand: " + str(sign) + " " + str(exp) + " " + add_point(bin(sig),10))

# Get initial guess for the significand of the reciprocal:
x0 = X0(sig & 0x3FF)
print("x0 = " + add_point(bin(x0),8))

# Iteration 1
# - sig has 10 digits to the right of the binary point
# - x0 has 8 digits to the right of the binary point
# - x1a has 18 digits to the right of the binary point
x1a = sig * x0 # D * x0
#print(add_point(bin(x1a),18))

x1b = 0b10_000000000000000000 - x1a # 2 - D*x0
#print(add_point(bin(x1b),18))

# x1 has 26 digits to the right of the binary point
x1 = x1b * x0 # x1 = (2 - D*x0) * x0
print("x1 = " + add_point(bin(x1),26))

# Normalize, if needed
if not bit(x1,26):
  rexp -= 1
  x1 <<= 1
print("After normalizing: x1 = " + add_point(add_point(add_point(add_point(bin(x1),26),17),16),15) + ", rexp = " + str(rexp))

# Round x1 to 11 bits:
# Step 1: Find the values needed to actually perform the rounding
print("roundingAttribute is " + args.roundingAttribute)

lastKeptBitIsOdd = bit(x1,26-10) == 1
print("lastKeptBitIsOdd is " + str(lastKeptBitIsOdd))

decidingBitIsOne = bit(x1,26-11) == 1
print("decidingBitIsOne is " + str(decidingBitIsOne))

remainingBitsAreNonzero = (x1 & 0x7FFF) != 0
print("remainingBitsAreNonzero is " + str(remainingBitsAreNonzero))

# Step 2: Perform the rounding
roundBit = 1 if (roundTiesToEven and decidingBitIsOne and (lastKeptBitIsOdd or remainingBitsAreNonzero)) or (roundTowardPositive and (not sign) and (decidingBitIsOne or remainingBitsAreNonzero)) or (roundTowardNegative and sign and (decidingBitIsOne or remainingBitsAreNonzero)) else 0
print("roundBit is " + str(roundBit))
x1 >>= 16
print("After truncating: x1 = " + add_point(bin(x1),10))
x1 += roundBit
print("After rounding: x1 = " + add_point(bin(x1),10))

# Step 3: Again, if needed, renormalize the rounded result
if bit(x1,11):
  rexp += 1
  x1 >>= 1

print("After renormalizing: x1 = " + add_point(bin(x1),10) + ", rexp = " + str(rexp))

print("Verify product is close to 1:")
print("- product of significands: " + add_point(bin(sig * x1),20+bit(x1,11)))
print("- sum of exponents: " + str(exp+rexp+bit(x1,11)))

if (rexp < -14) or (15 < rexp):
  sys.exit("Reciprocal is not a Normal IEEE 754 number.")

# Output reciprocal as a 16-bit hexadecimal integer:
sign = 0x8000 if sign else 0
print("Reciprocal is " + hex(sign | ((rexp + 15) << 10) | (x1 & 0x3FF)))
